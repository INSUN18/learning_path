# **一、概念讲解**

模型评估方法用于衡量机器学习模型在未见过的数据上的表现，也就是模型的“泛化能力”。下面逐条讲解各个知识点。

---

## **1. 训练集与测试集划分**

在训练机器学习模型时，需要两类数据：

* **训练集**：用于让模型“学习”规律。
* **测试集**：用于在模型学习完之后评估它的表现。

划分数据的目的，是确保测试集中的样本没有出现在训练集中，从而真实反映模型面对新数据时的性能。

---

## **2. 准确率（Accuracy）**

准确率表示模型预测正确的样本占全部样本的比例。

* 适用于分类问题。
* 常用于类别分布比较均衡的任务。

---

## **3. 精确率（Precision）**

精确率衡量“预测为正类的样本中，有多少是真正的正类”。

它关注“**预测的正类有多准**”。

---

## **4. 召回率（Recall）**

召回率衡量“真实的正类中，有多少被成功识别出来”。

它关注“**是否漏掉了正类**”。

---

## **5. F1 分数（F1 Score）**

F1 分数是精确率与召回率的调和平均，用于在二者之间取得平衡。

当任务中需要兼顾“预测准度”与“覆盖程度”时，F1 是常用指标。

---

## **6. 回归任务指标：MSE、MAE、R²**

回归任务输出为连续数值，因此需要专门的指标：

* **MSE（均方误差）**：预测误差的平方的平均值，强调大误差。
* **MAE（平均绝对误差）**：预测误差的绝对值的平均值，更直观、不夸大大误差。
* **R²（决定系数）**：衡量模型对观测值的解释能力，相当于“拟合程度”的比例。

---

# **二、理论分析**

本节给出数学公式、适用场景以及各指标优缺点。

---

## **1. 训练集与测试集划分的意义**

如果不划分训练/测试集，则模型可能仅仅“记住”数据，而无法应对新数据。划分数据能评估泛化性能，避免过拟合。

---

## **2. 分类指标**

### **2.1 准确率**

公式：

[
Accuracy = \frac{TP + TN}{TP + TN + FP + FN}
]

* **TP**：预测为正且真实为正
* **TN**：预测为负且真实为负
* **FP**：预测为正但真实为负
* **FN**：预测为负但真实为正

**适用场景：** 类别分布均衡，无特别偏好的分类任务。

**缺点：** 类别极不平衡时不可靠（例如 99% 样本为负类时，全部预测负类也能达到 99% 准确率）。

---

### **2.2 精确率**

[
Precision = \frac{TP}{TP + FP}
]

**适用场景：** 假阳性（FP）很昂贵时，例如垃圾邮件识别（不能误判正常邮件为垃圾邮件）。

**缺点：** 只关注预测的正类，不关注负类。

---

### **2.3 召回率**

[
Recall = \frac{TP}{TP + FN}
]

**适用场景：** 假阴性（FN）代价高时，例如疾病检测（不能漏诊）。

**缺点：** 不关注 FP，因此可能导致过多误报。

---

### **2.4 F1 分数**

[
F1 = 2 \cdot \frac{Precision \cdot Recall}{Precision + Recall}
]

**适用场景：**

* 精确率和召回率都很重要
* 数据类别不平衡时

**优点：** 在两者之间取得均衡。
**缺点：** 无法反映 TN 的信息。

---

## **3. 回归任务指标**

### **3.1 MSE**

[
MSE = \frac{1}{n} \sum_{i=1}^n (y_i - \hat{y}_i)^2
]

**适用场景：** 强调大误差需要特别关注的任务。

---

### **3.2 MAE**

[
MAE = \frac{1}{n} \sum_{i=1}^n |y_i - \hat{y}_i|
]

**适用场景：** 希望误差评估更平滑、不放大异常点。

---

### **3.3 R²**

[
R^2 = 1 - \frac{\sum (y_i - \hat{y}_i)^2}{\sum (y_i - \bar{y})^2}
]

含义：

* 当模型完全拟合数据时，R² = 1
* 当模型和均值预测一样差时，R² = 0
* 当模型比均值预测还差时，R² < 0

**适用场景：** 需要评估模型整体解释能力时。

---

# **三、实例演示（构造虚拟数据）**

这里使用简单的手工构造数据进行示例。

---

## **1. 分类任务示例**

### **真实标签（y_true）**

```
1, 0, 1, 1, 0
```

### **预测标签（y_pred）**

```
1, 0, 0, 1, 1
```

### **混淆矩阵计算**

| 样本 | y_true | y_pred | 结果 |
| -- | ------ | ------ | -- |
| #1 | 1      | 1      | TP |
| #2 | 0      | 0      | TN |
| #3 | 1      | 0      | FN |
| #4 | 1      | 1      | TP |
| #5 | 0      | 1      | FP |

得到：

* TP = 2
* TN = 1
* FP = 1
* FN = 1

计算：

* **准确率** = (2 + 1) / 5 = 0.6
* **精确率** = 2 / (2 + 1) = 0.666...
* **召回率** = 2 / (2 + 1) = 0.666...
* **F1** = 2 × (0.666 × 0.666) / (0.666 + 0.666) = 0.666...

---

## **2. 回归任务示例**

构造：

* y_true: [3, 5, 2, 7]
* y_pred: [2, 5, 4, 6]

逐项误差：

| i | y_true | y_pred | 误差 | 平方误差 | 绝对误差 |
| - | ------ | ------ | -- | ---- | ---- |
| 1 | 3      | 2      | 1  | 1    | 1    |
| 2 | 5      | 5      | 0  | 0    | 0    |
| 3 | 2      | 4      | -2 | 4    | 2    |
| 4 | 7      | 6      | 1  | 1    | 1    |

计算：

* **MSE = (1 + 0 + 4 + 1) / 4 = 1.5**
* **MAE = (1 + 0 + 2 + 1) / 4 = 1**
* R² 计算需先求均值
  [
  \bar{y} = (3+5+2+7)/4 = 4.25
  ]
  [
  SS_{res} = 1+0+4+1 = 6
  ]
  [
  SS_{tot} = (3-4.25)^2 + (5-4.25)^2 + (2-4.25)^2 + (7-4.25)^2 = 14.75
  ]
  [
  R^2 = 1 - 6/14.75 ≈ 0.593
  ]

---

# **四、代码示例（可直接运行）**

```python
import numpy as np

# ===============================
# 1. 构造分类任务示例数据
# ===============================
y_true_cls = np.array([1, 0, 1, 1, 0])
y_pred_cls = np.array([1, 0, 0, 1, 1])

# 计算混淆矩阵元素
TP = np.sum((y_true_cls == 1) & (y_pred_cls == 1))
TN = np.sum((y_true_cls == 0) & (y_pred_cls == 0))
FP = np.sum((y_true_cls == 0) & (y_pred_cls == 1))
FN = np.sum((y_true_cls == 1) & (y_pred_cls == 0))

# 分类指标
accuracy = (TP + TN) / len(y_true_cls)
precision = TP / (TP + FP)
recall = TP / (TP + FN)
f1 = 2 * precision * recall / (precision + recall)

print("分类任务指标：")
print("Accuracy:", accuracy)
print("Precision:", precision)
print("Recall:", recall)
print("F1 Score:", f1)


# ===============================
# 2. 构造回归任务示例数据
# ===============================
y_true_reg = np.array([3, 5, 2, 7])
y_pred_reg = np.array([2, 5, 4, 6])

# 回归指标
mse = np.mean((y_true_reg - y_pred_reg) ** 2)
mae = np.mean(np.abs(y_true_reg - y_pred_reg))
r2 = 1 - np.sum((y_true_reg - y_pred_reg) ** 2) / np.sum((y_true_reg - np.mean(y_true_reg)) ** 2)

print("\n回归任务指标：")
print("MSE:", mse)
print("MAE:", mae)
print("R2:", r2)
```

---

# **五、总结**

## **1. 指标适用场景**

| 任务 | 指标  | 适用场景             |
| -- | --- | ---------------- |
| 分类 | 准确率 | 类别均衡，整体评估        |
| 分类 | 精确率 | 假阳性代价高           |
| 分类 | 召回率 | 假阴性代价高           |
| 分类 | F1  | 精确率与召回率需兼顾，类别不平衡 |
| 回归 | MSE | 强调大误差，使用广泛       |
| 回归 | MAE | 误差更稳健，不放大异常点     |
| 回归 | R²  | 衡量整体拟合效果         |

---

## **2. 选择指标时需注意的问题**

* 类别不平衡时，准确率常常失效。
* 精确率和召回率通常是此消彼长，需要根据任务取舍。
* 回归任务的指标没有优劣之分，关键看业务需求是强调“平均误差”还是“严重误差”。

---

## **3. 分类与回归的根本差异**

* **分类指标**围绕混淆矩阵，关注“对/错”关系。
* **回归指标**基于误差尺度，关注“预测值与真实数值的偏差”。
